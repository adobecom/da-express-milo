{
  "version": 3,
  "sources": ["ColorController.ts"],
  "sourcesContent": ["/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nimport type { ReactiveElement } from 'lit';\nimport Color from 'colorjs.io';\nimport type {\n    ColorObject,\n    ColorTypes as DefaultColorTypes,\n} from 'colorjs.io/types/src/color';\nimport type ColorSpace from 'colorjs.io/types/src/space';\n\n/**\n * Represents various color types that can be used in the application.\n *\n * This type can be one of the following:\n * - `DefaultColorTypes`: A predefined set of color types.\n * - An object representing an RGBA color with properties:\n *   - `r`: Red component, can be a number or string.\n *   - `g`: Green component, can be a number or string.\n *   - `b`: Blue component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n * - An object representing an HSLA color with properties:\n *   - `h`: Hue component, can be a number or string.\n *   - `s`: Saturation component, can be a number or string.\n *   - `l`: Lightness component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n * - An object representing an HSVA color with properties:\n *   - `h`: Hue component, can be a number or string.\n *   - `s`: Saturation component, can be a number or string.\n *   - `v`: Value component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n */\ntype ColorTypes =\n    | DefaultColorTypes\n    | {\n          r: number | string;\n          g: number | string;\n          b: number | string;\n          a?: number | string;\n      }\n    | {\n          h: number | string;\n          s: number | string;\n          l: number | string;\n          a?: number | string;\n      }\n    | {\n          h: number | string;\n          s: number | string;\n          v: number | string;\n          a?: number | string;\n      };\n\nexport type { Color, ColorTypes };\n\ntype ColorValidationResult = {\n    spaceId: string | null;\n    coords: number[];\n    isValid: boolean;\n    alpha: number;\n};\n\n/**\n * The `ColorController` class is responsible for managing and validating color values\n * in various color spaces (RGB, HSL, HSV, Hex). It provides methods to set, get, and\n * validate colors, as well as convert between different color formats.\n *\n * @class\n * @property {Color} color - Gets or sets the current color value.\n * @property {ColorTypes} colorValue - Gets the color value in various formats based on the original color input.\n * @property {number} hue - Gets or sets the hue value of the current color.\n *\n * @method validateColorString(color: string): ColorValidationResult - Validates a color string and returns the validation result.\n * @method getColor(format: string | ColorSpace): ColorObject - Converts the current color to the specified format.\n * @method getHslString(): string - Returns the current color in HSL string format.\n * @method savePreviousColor(): void - Saves the current color as the previous color.\n * @method restorePreviousColor(): void - Restores the previous color.\n *\n * @constructor\n * @param {ReactiveElement} host - The host element that uses this controller.\n * @param {Object} [options] - Optional configuration options.\n * @param {string} [options.manageAs] - Specifies the color space to manage the color as.\n */\n\nexport class ColorController {\n    get color(): Color {\n        return this._color;\n    }\n\n    /**\n     * Validates a color string and returns a result indicating the color space,\n     * coordinates, alpha value, and whether the color is valid.\n     *\n     * @param color - The color string to validate. Supported formats include:\n     *  - RGB: `rgb(r, g, b)`, `rgba(r, g, b, a)`, `rgb r g b`, `rgba r g b a`\n     *  - HSL: `hsl(h, s, l)`, `hsla(h, s, l, a)`, `hsl h s l`, `hsla h s l a`\n     *  - HSV: `hsv(h, s, v)`, `hsva(h, s, v, a)`, `hsv h s v`, `hsva h s v a`\n     *  - HEX: `#rgb`, `#rgba`, `#rrggbb`, `#rrggbbaa`\n     *\n     * @returns An object containing the following properties:\n     *  - `spaceId`: The color space identifier (`'srgb'`, `'hsl'`, or `'hsv'`).\n     *  - `coords`: An array of numeric values representing the color coordinates.\n     *  - `alpha`: The alpha value of the color (0 to 1).\n     *  - `isValid`: A boolean indicating whether the color string is valid.\n     */\n    public validateColorString(color: string): ColorValidationResult {\n        const result: ColorValidationResult = {\n            spaceId: null,\n            coords: [0, 0, 0],\n            isValid: false,\n            alpha: 1,\n        };\n\n        const rgbRegExpArray = [\n            /rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i,\n            /rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)/i,\n            /^rgba\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(0|0?\\.\\d+|1)\\s*$/i,\n            /^rgb\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s*$/i,\n            /^rgba\\(\\s*(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d*\\.?\\d+)\\s*\\)$/i,\n            /^rgb\\(\\s*(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s*\\)$/i,\n            /rgb\\(\\s*(100|[0-9]{1,2}%)\\s*,\\s*(100|[0-9]{1,2}%)\\s*,\\s*(100|[0-9]{1,2}%)\\s*\\)/i,\n            /rgba\\(\\s*(100|[0-9]{1,2})%\\s*,\\s*(100|[0-9]{1,2})%\\s*,\\s*(100|[0-9]{1,2})%\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i,\n        ];\n        const hslRegExpArray = [\n            /hsla\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i,\n            /hsl\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*\\)/i,\n            /^hsla\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*$/i,\n            /^hsl\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*$/i,\n            /^hsla\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*\\)$/i,\n            /^hsl\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*\\)$/i,\n        ];\n        const hsvRegExpArray = [\n            /hsva\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i,\n            /hsv\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*\\)/i,\n            /^hsva\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*$/i,\n            /^hsv\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*$/i,\n            /^hsva\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*\\)$/i,\n            /^hsv\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*\\)$/i,\n        ];\n        const hexRegExpArray = [\n            /^#([A-Fa-f0-9]{6})(?:\\s*([01](?:\\.\\d+)?))?$/,\n            /^#([A-Fa-f0-9]{3})(?:\\s*([01](?:\\.\\d+)?))?$/,\n        ];\n\n        const rgbaMatch = rgbRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hslaMatch = hslRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hsvaMatch = hsvRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hexMatch = hexRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n\n        if (rgbaMatch) {\n            const [, r, g, b, a] = rgbaMatch.filter(\n                (element) => typeof element === 'string'\n            );\n            const alpha = a === undefined ? 1 : Number(a);\n            const processValue = (value: string): number => {\n                if (value.includes('%')) {\n                    return Number(value.replace('%', '')) / 100;\n                } else {\n                    return Number(value) / 255;\n                }\n            };\n            const numericR = processValue(r);\n            const numericG = processValue(g);\n            const numericB = processValue(b);\n\n            result.spaceId = 'srgb';\n            result.coords = [numericR, numericG, numericB];\n            result.alpha = alpha;\n            result.isValid =\n                numericR >= 0 &&\n                numericR <= 1 &&\n                numericG >= 0 &&\n                numericG <= 1 &&\n                numericB >= 0 &&\n                numericB <= 1 &&\n                alpha >= 0 &&\n                alpha <= 1;\n        } else if (hslaMatch) {\n            const [, h, s, l, a] = hslaMatch;\n            const values = [h, s, l, a === undefined ? '1' : a].map((value) =>\n                Number(value.replace(/[^\\d.]/g, ''))\n            );\n            const [numericH, numericS, numericL, numericA] = values;\n\n            result.spaceId = 'hsl';\n            result.coords = [numericH, numericS, numericL];\n            result.alpha = numericA;\n            result.isValid =\n                numericH >= 0 &&\n                numericH <= 360 &&\n                numericS >= 0 &&\n                numericS <= 100 &&\n                numericL >= 0 &&\n                numericL <= 100 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        } else if (hsvaMatch) {\n            const [, h, s, v, a] = hsvaMatch;\n            const values = [h, s, v, a === undefined ? '1' : a].map((value) =>\n                Number(value.replace(/[^\\d.]/g, ''))\n            );\n            const [numericH, numericS, numericV, numericA] = values;\n\n            result.spaceId = 'hsv';\n            result.coords = [numericH, numericS, numericV];\n            result.alpha = numericA;\n            result.isValid =\n                numericH >= 0 &&\n                numericH <= 360 &&\n                numericS >= 0 &&\n                numericS <= 100 &&\n                numericV >= 0 &&\n                numericV <= 100 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        } else if (hexMatch) {\n            const [, hex, alpha] = hexMatch;\n\n            // Function to process 2-digit or repeated 1-digit hex\n            const processHex = (hex: string): number => {\n                // For 3-digit hex values, repeat each digit\n                if (hex.length === 1) {\n                    hex = hex + hex;\n                }\n                return parseInt(hex, 16) / 255;\n            };\n\n            // Handle both 3-digit and 6-digit hex\n            let numericR, numericG, numericB;\n            if (hex.length === 3) {\n                // 3-digit hex (e.g., #3a7 -> #33aa77)\n                numericR = processHex(hex.substring(0, 1));\n                numericG = processHex(hex.substring(1, 2));\n                numericB = processHex(hex.substring(2, 3));\n            } else {\n                // 6-digit hex (e.g., #33aa77)\n                numericR = processHex(hex.substring(0, 2));\n                numericG = processHex(hex.substring(2, 4));\n                numericB = processHex(hex.substring(4, 6));\n            }\n\n            // Numeric alpha: if not provided, default to 1\n            const numericA = alpha ? Number(alpha) : 1;\n\n            // Validate the color values\n            result.spaceId = 'srgb';\n            result.coords = [numericR, numericG, numericB];\n            result.alpha = numericA;\n            result.isValid =\n                numericR >= 0 &&\n                numericR <= 1 &&\n                numericG >= 0 &&\n                numericG <= 1 &&\n                numericB >= 0 &&\n                numericB <= 1 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Represents the color state of the component.\n     * Initialized with an HSV color model with hue 0, saturation 100, and value 100, and an alpha value of 1.\n     *\n     * @private\n     * @type {Color}\n     */\n    private _color: Color = new Color('hsv', [0, 100, 100], 1);\n\n    /**\n     * Represents the original color value provided by the user.\n     *\n     * @private\n     * @type {ColorTypes}\n     */\n    private _colorOrigin!: ColorTypes;\n\n    /**\n     * Gets the original color value provided by the user.\n     *\n     * @returns {ColorTypes} The original color value.\n     */\n    get colorOrigin(): ColorTypes {\n        return this._colorOrigin;\n    }\n\n    /**\n     * Sets the original color value provided by the user.\n     *\n     * @param {ColorTypes} colorOrigin - The original color value to set.\n     */\n    set colorOrigin(colorOrigin: ColorTypes) {\n        this._colorOrigin = colorOrigin;\n    }\n\n    /**\n     * An optional string property that specifies how the color should be managed(its value is the name of color space in which color object will be managed).\n     * This property can be used to define a specific management strategy or identifier.\n     */\n    private manageAs?: string;\n\n    /**\n     * Stores the previous color value.\n     * This is used to keep track of the color before any changes are made.\n     *\n     * @private\n     */\n    private _previousColor!: Color;\n\n    /**\n     * Sets the color value for the controller. The color can be provided in various formats:\n     * - A string representing a color name, hex code, or other color format.\n     * - An instance of the `Color` class.\n     * - An object containing color properties such as `h`, `s`, `l`, `v`, `r`, `g`, `b`, and optionally `a`.\n     *\n     * The method validates and parses the input color, converting it to a `Color` instance.\n     * If the color is invalid, it attempts to parse it as a hex code or returns without setting a new color.\n     *\n     * @param {ColorTypes} color - The color value to set. It can be a string, an instance of `Color`, or an object with color properties.\n     */\n    set color(color: ColorTypes) {\n        this._colorOrigin = color;\n        let newColor!: Color;\n        if (typeof color === 'string') {\n            const colorValidationResult = this.validateColorString(\n                color as string\n            );\n            if (colorValidationResult.isValid) {\n                const [coord1, coord2, coord3] = colorValidationResult.coords;\n                newColor = new Color(\n                    `${colorValidationResult.spaceId}`,\n                    [coord1, coord2, coord3],\n                    colorValidationResult.alpha\n                );\n            } else {\n                try {\n                    Color.parse(color);\n                } catch (error) {\n                    try {\n                        newColor = new Color(`#${color}`);\n                    } catch (error) {\n                        return;\n                    }\n                }\n            }\n        } else if (color instanceof Color) {\n            newColor = color;\n        } else if (!Array.isArray(color)) {\n            const { h, s, l, v, r, g, b, a } = color as {\n                h: string;\n                s: string;\n                l: string;\n                v: string;\n                r: string;\n                g: string;\n                b: string;\n                a?: string;\n            };\n            if (typeof h !== 'undefined' && typeof s !== 'undefined') {\n                const lv = l ?? v;\n                newColor = new Color(\n                    typeof l !== 'undefined' ? 'hsl' : 'hsv',\n                    [\n                        parseFloat(h),\n                        typeof s !== 'string' ? s * 100 : parseFloat(s),\n                        typeof lv !== 'string' ? lv * 100 : parseFloat(lv),\n                    ],\n                    parseFloat(a || '1')\n                );\n            } else if (\n                typeof r !== 'undefined' &&\n                typeof g !== 'undefined' &&\n                typeof b !== 'undefined'\n            ) {\n                newColor = new Color(\n                    'srgb',\n                    [\n                        parseFloat(r) / 255,\n                        parseFloat(g) / 255,\n                        parseFloat(b) / 255,\n                    ],\n                    parseFloat(a || '1')\n                );\n            }\n        }\n\n        if (!newColor) {\n            newColor = new Color(color as DefaultColorTypes);\n        }\n\n        if (this.manageAs) {\n            this._color = newColor.to(this.manageAs) as Color;\n        } else {\n            this._color = newColor;\n        }\n        this.host.requestUpdate();\n    }\n\n    /**\n     * Gets the color value in various formats based on the original color input.\n     *\n     * The method determines the color space of the original color input and converts\n     * the color to the appropriate format. The supported color spaces are:\n     * - HSV (Hue, Saturation, Value)\n     * - HSL (Hue, Saturation, Lightness)\n     * - Hexadecimal (with or without alpha)\n     * - RGB (Red, Green, Blue) with optional alpha\n     *\n     * @returns {ColorTypes} The color value in the appropriate format.\n     *\n     * The method handles the following cases:\n     * - If the original color input is a string, it checks the prefix to determine the color space.\n     * - If the original color input is an object, it checks the properties to determine the color space.\n     * - If the original color input is not provided, it defaults to the current color space of the color object.\n     *\n     * The returned color value can be in one of the following formats:\n     * - `hsv(h, s%, v%)` or `hsva(h, s%, v%, a)`\n     * - `hsl(h, s%, l%)` or `hsla(h, s%, l%, a)`\n     * - `#rrggbb` or `#rrggbbaa`\n     * - `rgb(r, g, b)` or `rgba(r, g, b, a)`\n     * - `{ h, s, v, a }` for HSV object\n     * - `{ h, s, l, a }` for HSL object\n     * - `{ r, g, b, a }` for RGB object\n     */\n    get colorValue(): ColorTypes {\n        if (typeof this._colorOrigin === 'string') {\n            let spaceId = '';\n            if (this._colorOrigin.startsWith('#')) {\n                spaceId = 'hex string';\n            } else if (this._colorOrigin.startsWith('rgb')) {\n                spaceId = 'rgb';\n            } else if (this._colorOrigin.startsWith('hsl')) {\n                spaceId = 'hsl';\n            } else if (this._colorOrigin.startsWith('hsv')) {\n                spaceId = 'hsv';\n            } else {\n                spaceId = 'hex';\n            }\n            switch (spaceId) {\n                case 'hsv': {\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const { h, s, v } = (this._color.to('hsv') as Color).hsv;\n                    const a = this._color.alpha;\n                    return `hsv${hadAlpha ? `a` : ''}(${Math.round(\n                        h\n                    )}, ${Math.round(s)}%, ${Math.round(v)}%${\n                        hadAlpha ? `, ${a}` : ''\n                    })`;\n                }\n                case 'hsl': {\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const { h, s, l } = (this._color.to('hsl') as Color).hsl;\n                    const a = this._color.alpha;\n                    return `hsl${hadAlpha ? `a` : ''}(${Math.round(\n                        h\n                    )}, ${Math.round(s)}%, ${Math.round(l)}%${\n                        hadAlpha ? `, ${a}` : ''\n                    })`;\n                }\n                case 'hex string': {\n                    const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                    const hadAlpha =\n                        this._colorOrigin.length === 5 ||\n                        this._colorOrigin.length === 9;\n                    const a = this._color.alpha;\n                    const rHex = Math.round(r * 255).toString(16);\n                    const gHex = Math.round(g * 255).toString(16);\n                    const bHex = Math.round(b * 255).toString(16);\n                    const aHex = Math.round(a * 255).toString(16);\n                    return `#${rHex.padStart(2, '0')}${gHex.padStart(\n                        2,\n                        '0'\n                    )}${bHex.padStart(2, '0')}${\n                        hadAlpha ? aHex.padStart(2, '0') : ''\n                    }`;\n                }\n                case 'hex': {\n                    const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                    const hadAlpha =\n                        this._colorOrigin.length === 4 ||\n                        this._colorOrigin.length === 8;\n                    const a = this._color.alpha;\n                    const rHex = Math.round(r * 255).toString(16);\n                    const gHex = Math.round(g * 255).toString(16);\n                    const bHex = Math.round(b * 255).toString(16);\n                    const aHex = Math.round(a * 255).toString(16);\n                    return `${rHex.padStart(2, '0')}${gHex.padStart(\n                        2,\n                        '0'\n                    )}${bHex.padStart(2, '0')}${\n                        hadAlpha ? aHex.padStart(2, '0') : ''\n                    }`;\n                }\n                //rgb\n                default: {\n                    const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const a = this._color.alpha;\n                    if (this._colorOrigin.search('%') > -1) {\n                        return `rgb${hadAlpha ? `a` : ''}(${Math.round(r * 100)}%, ${Math.round(\n                            g * 100\n                        )}%, ${Math.round(b * 100)}%${hadAlpha ? `,${Math.round(a * 100)}%` : ''})`;\n                    }\n                    return `rgb${hadAlpha ? `a` : ''}(${Math.round(r * 255)}, ${Math.round(\n                        g * 255\n                    )}, ${Math.round(b * 255)}${hadAlpha ? `, ${a}` : ''})`;\n                }\n            }\n        }\n        let spaceId;\n        if (this._colorOrigin) {\n            try {\n                ({ spaceId } = new Color(\n                    this._colorOrigin as DefaultColorTypes\n                ));\n            } catch (error) {\n                const { h, s, l, v, r, g, b } = this._colorOrigin as {\n                    h: string;\n                    s: string;\n                    l: string;\n                    v: string;\n                    r: string;\n                    g: string;\n                    b: string;\n                };\n                if (\n                    typeof h !== 'undefined' &&\n                    typeof s !== 'undefined' &&\n                    typeof l !== 'undefined'\n                ) {\n                    spaceId = 'hsl';\n                } else if (\n                    typeof h !== 'undefined' &&\n                    typeof s !== 'undefined' &&\n                    typeof v !== 'undefined'\n                ) {\n                    spaceId = 'hsv';\n                } else if (\n                    typeof r !== 'undefined' &&\n                    typeof g !== 'undefined' &&\n                    typeof b !== 'undefined'\n                ) {\n                    spaceId = 'srgb';\n                }\n            }\n        } else {\n            ({ spaceId } = this.color);\n        }\n        switch (spaceId) {\n            case 'hsv': {\n                const { h, s, v } = (this._color.to('hsv') as Color).hsv;\n                return {\n                    h,\n                    s: s / 100,\n                    v: v / 100,\n                    a: this._color.alpha,\n                };\n            }\n            case 'hsl': {\n                const { h, s, l } = (this._color.to('hsl') as Color).hsl;\n                return {\n                    h,\n                    s: s / 100,\n                    l: l / 100,\n                    a: this._color.alpha,\n                };\n            }\n            case 'srgb': {\n                const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                if (\n                    this._colorOrigin &&\n                    typeof (this._colorOrigin as { r: string }).r ===\n                        'string' &&\n                    (this._colorOrigin as { r: string }).r.search('%')\n                ) {\n                    return {\n                        r: `${Math.round(r * 255)}%`,\n                        g: `${Math.round(g * 255)}%`,\n                        b: `${Math.round(b * 255)}%`,\n                        a: this._color.alpha,\n                    };\n                }\n                return {\n                    r: Math.round(r * 255),\n                    g: Math.round(g * 255),\n                    b: Math.round(b * 255),\n                    a: this._color.alpha,\n                };\n            }\n        }\n        return this._color;\n    }\n\n    protected host: ReactiveElement;\n\n    /**\n     * Gets the hue value of the current color in HSL format.\n     *\n     * @returns {number} The hue value as a number.\n     */\n    get hue(): number {\n        return Number((this._color.to('hsl') as Color).hsl.h);\n    }\n\n    /**\n     * Sets the hue value of the color and requests an update from the host.\n     *\n     * @param hue - The hue value to set, represented as a number.\n     */\n    set hue(hue: number) {\n        this._color.set('h', hue);\n        this.host.requestUpdate();\n    }\n\n    /**\n     * Creates an instance of ColorController.\n     *\n     * @param host - The ReactiveElement that this controller is associated with.\n     * @param options - An object containing optional parameters.\n     * @param options.manageAs - A string to manage the controller as a specific type.\n     */\n    constructor(\n        host: ReactiveElement,\n        {\n            manageAs,\n        }: {\n            manageAs?: string;\n        } = {}\n    ) {\n        this.host = host;\n        this.manageAs = manageAs;\n    }\n\n    /**\n     * Converts the current color to the specified format.\n     *\n     * @param format - The desired color format. It can be a string representing one of the valid formats\n     * ('srgb', 'hsva', 'hsv', 'hsl', 'hsla') or a ColorSpace object.\n     * @returns The color object in the specified format.\n     * @throws Will throw an error if the provided format is not a valid string format.\n     */\n    getColor(format: string | ColorSpace): ColorObject {\n        const validFormats = ['srgb', 'hsva', 'hsv', 'hsl', 'hsla'];\n        if (typeof format === 'string' && !validFormats.includes(format)) {\n            throw new Error('not a valid format');\n        }\n\n        return this._color.to(format);\n    }\n\n    /**\n     * Converts the current color to an HSL string representation.\n     *\n     * @returns {string} The HSL string representation of the current color.\n     */\n    getHslString(): string {\n        return this._color.to('hsl').toString();\n    }\n\n    /**\n     * Saves the current color state by cloning the current color and storing it\n     * as the previous color. This allows for the ability to revert to the previous\n     * color state if needed.\n     *\n     * @returns {void}\n     */\n    savePreviousColor(): void {\n        this._previousColor = this._color.clone();\n    }\n\n    /**\n     * Restores the color to the previously saved color value.\n     *\n     * This method sets the current color (`_color`) to the previously stored color (`_previousColor`).\n     */\n    restorePreviousColor(): void {\n        this._color = this._previousColor;\n    }\n}\n"],
  "mappings": "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",
  "names": ["Color", "host", "manageAs", "color", "_a", "_b", "_c", "_d", "result", "rgbRegExpArray", "hslRegExpArray", "hsvRegExpArray", "hexRegExpArray", "rgbaMatch", "regex", "hslaMatch", "hsvaMatch", "hexMatch", "r", "g", "b", "a", "element", "alpha", "processValue", "value", "numericR", "numericG", "numericB", "h", "s", "l", "values", "numericH", "numericS", "numericL", "numericA", "v", "numericV", "hex", "processHex", "colorOrigin", "newColor", "colorValidationResult", "coord1", "coord2", "coord3", "error", "lv", "spaceId", "hadAlpha", "rHex", "gHex", "bHex", "aHex", "hue", "format"]
}
